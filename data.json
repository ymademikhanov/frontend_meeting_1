data = {"lines":["#include \u003ciostream\u003e","#include \u003cvector\u003e","","","using namespace std;","","class MinHeap {","\tvector\u003cint\u003e elements;","\t","\tpublic:","\tMinHeap() {","\t\telements \u003d  vector\u003cint\u003e();","\t}","\t","\tint getParentIndex(int index) {","\t\treturn int((index - 1) / 2);","\t}","\t","\tint getLeftChildIndex(int index) {","\t\treturn (index + 1) * 2 - 1;","\t}","\t","\tint getRightChildIndex(int index) {","\t\treturn (index + 1) * 2;","\t}","\t","\tvoid update_up(int index) {","\t\twhile (index \u003e 0) {","\t\t\tint parent \u003d this -\u003e getParentIndex(index);","\t\t\tif (elements[parent] \u003e elements[index])","\t\t\t\tswap(elements[parent], elements[index]);","\t\t\tindex \u003d this -\u003e getParentIndex(index);","\t\t}","\t}","\t","\tvoid insert(int value) {","\t\telements.push_back(value);","\t\tint index \u003d elements.size() - 1;","\t\tthis -\u003e update_up(index);","\t}","\t","\tint getMin() {","\t\tif (elements.size() \u003e 0)","\t\t\treturn elements[0];","\t\t// or throw an exception.","\t\treturn -1;","\t}","\t","\tvoid update_down() {","\t\tint index \u003d 0;","\t\twhile (index \u003c elements.size()) {","\t\t\tint leftChild \u003d this -\u003e getLeftChildIndex(index);","\t\t\tint rightChild \u003d this -\u003e getRightChildIndex(index);","\t\t\tif (leftChild \u003c elements.size() \u0026\u0026 elements[leftChild] \u003c elements[rightChild]) {","\t\t\t\tswap(elements[leftChild], elements[index]);","\t\t\t\tindex \u003d leftChild;","\t\t\t} else {","\t\t\t\tif (rightChild \u003c elements.size())","\t\t\t\t\tswap(elements[rightChild], elements[index]);","\t\t\t\tindex \u003d rightChild;","\t\t\t}","\t\t}","\t}","\t","\tvoid extract() {","\t\tif (elements.size() \u003e 0) {","\t\t\telements.front() \u003d elements.back();","\t\t\telements.pop_back();","\t\t\tthis -\u003e update_down();","\t\t} else {","\t\t\tprintf(\"Heap is empty!\");","\t\t}","\t}","};","","int main() {","\t// your code goes here","\t","\tMinHeap myheap;","\t","\t","\tint n, x;","\tcin \u003e\u003e n;","\tfor (int i \u003d 0; i \u003c n; i++) {","\t\tcin \u003e\u003e x;","\t\tmyheap.insert(x);","\t}","\t","\tvector \u003cint\u003e ss;","\t","\tfor (int i \u003d 0; i \u003c n; i++) {","\t\tss.push_back(myheap.getMin());","\t\tmyheap.extract();","\t}","\t","\tfor (int i \u003d 0; i \u003c ss.size(); i++)","\t\tcout \u003c\u003c ss[i] \u003c\u003c \" \";","\t\t","\tcout \u003c\u003c endl;","\t","\treturn 0;","}"],"comments":[{"start":1,"end":7,"author":"ymademikhanov","comment":"This method is unnecessary."},{"start":6,"end":10,"author":"leha.raketa96","comment":"The class coherenece is weak. The class coherenece is weak. "},{"start":2,"end":5,"author":"ibro","comment":"The method does not make sense."}]}
